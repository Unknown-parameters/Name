<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.2" halcon_version="18.11.1.1">
<procedure name="main">
<interface/>
<body>
<c>* This example program shows how several images of a PCB can be combined</c>
<c>* into a large mosaic image of the PCB.  The program shows how to use</c>
<c>* proj_match_points_ransac and gen_projective_mosaic to achieve this.</c>
<c>* Please note that the PCB has some degradations on its surface, which look</c>
<c>* like folds and may easily be mistaken as the seams between the images</c>
<c>* in the mosaic image.  To show that this is not the case, the program</c>
<c>* also displays the true seams of the mosaic image.</c>
<l>dev_update_off ()</l>
<l>dev_close_window ()</l>
<l>dev_open_window (0, 0, 640, 480, 'white', WindowHandle)</l>
<l>dev_set_color ('green')</l>
<l>numdata:=6</l>
<l>set_display_font (WindowHandle, 14, 'mono', 'true', 'false')</l>
<c>* Read in the images and show them one-by-one.  Please not the fold-like</c>
<c>* degradations running across the PCB.</c>
<l>gen_empty_obj (Images)</l>
<l>* for J := 1 to 6 by 1</l>
<l>*     read_image (Image, 'mosaic/pcb_' + J$'02')</l>
<l>*     concat_obj (Images, Image, Images)</l>
<l>*     dev_display (Image)</l>
<l>*     disp_message (WindowHandle, 'Image ' + J$'d', 'window', 12, 12, 'black', 'true')</l>
<l>*     wait_seconds (1)</l>
<l>* endfor</l>
<c></c>
<c></c>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,1]" as_ord="1">* Image Acquisition 01: Code generated by Image Acquisition 01</c>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[1,2,1]" as_ord="1">open_framegrabber ('MindVision17_X64', 1, 1, 0, 0, 0, 0, 'progressive', 8, 'BGR24', -1, 'false', 'auto', 'Camera MV-GE134GC#A9FEC3EE', 0, -1, AcqHandle)</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,1]" as_ord="1">grab_image_start (AcqHandle, -1)</l>
<l>for J := 1 to numdata by 1</l>
<l as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,3]" as_ord="1">             grab_image_async (Image, AcqHandle, -1)</l>
<l>             concat_obj (Images, Image, Images)</l>
<c as_id="image_acquisition" as_name="Image Acquisition 01" as_grp="[2,4]" as_ord="1">             * Image Acquisition 01: Do something</c>
<l>endfor</l>
<c></c>
<l>disp_continue_message (WindowHandle, 'black', 'true')</l>
<l>stop ()</l>
<c>* To show the point matches that are used to compute the projective</c>
<c>* transformation between the images, we will show all images in a large</c>
<c>* tiled image with some space between the images so that the extents</c>
<c>* of the images are easily visible.</c>
<l>dev_set_window_extents (-1, -1, 640 / 4, 2980 / 4)</l>
<l> get_image_size (Images, Width, Height)</l>
<l>TileSpacingRow := 0</l>
<l>TileSpacingColumn := 0</l>
<l>TiledWidth := 1 * Width[1] + 1 * TileSpacingColumn</l>
<l>TiledHeight := 300 * Height[1] + 99*TileSpacingRow</l>
<l>dev_set_window_extents (-1, -1, TiledWidth , TiledHeight)</l>
<l>OffsetRow := Height[1] + TileSpacingRow</l>
<l>OffsetColumn := Width[1] + TileSpacingColumn</l>
<l>offrow:=[]</l>
<l>offcol:=[]</l>
<l>offmat:=[]</l>
<l>From:=[]</l>
<l>To:=[]</l>
<l>for i:= 0 to numdata-1 by 1</l>
<l>             offrow[i]:= i*OffsetRow</l>
<l>             offcol[i]:=0</l>
<l>             offmat[i]:=-1</l>
<c>             </c>
<l>endfor</l>
<c></c>
<l>for j := 1 to numdata-1 by 1</l>
<l>             From[j-1]:=j</l>
<l>             To[j-1]:=j+1</l>
<l>endfor</l>
<l>stop()</l>
<c>*改变平铺的位置</c>
<c></c>
<l>tile_images_offset(Images,TiledImage,offrow,offcol, offmat, offmat, offmat, offmat, TiledWidth, TiledHeight)</l>
<c></c>
<l>* tile_images_offset (Images, TiledImage, [0,500,1000,1500,2000,2500], [0,0,0,0,0,0], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], [-1,-1,-1,-1,-1,-1], 640, 2980)</l>
<l>dev_clear_window ()</l>
<l>dev_display (TiledImage)</l>
<l>* disp_message (WindowHandle, 'All 6 images', 'window', 12, 12, 'black', 'true')</l>
<l>* disp_message (WindowHandle, 'Click \'Run\'\nto continue', 'window', 2980 / 4 - 50, 12, 'black', 'true')</l>
<l>stop ()</l>
<c>* Now we compute point matches between the five pairs of images and with this</c>
<c>* the projective transformation between the image pairs.  Note that the code</c>
<c>* below calls the point operator for each image pair.  Since the images form</c>
<c>* a strip, with a little book keeping we could make the process a little more</c>
<c>* efficient by saving the points from the last iteration (ImageT in pair J will</c>
<c>* be identical to ImageF in pair J+1).  This is not done here because such an</c>
<c>* optimization would be quite cumbersome in the general case where the images</c>
<c>* can lie in a general configuration that cannot be represented by a strip.</c>
<l>dev_clear_window ()</l>
<l>dev_display (TiledImage)</l>
<l>disp_message (WindowHandle, 'Point matches', 'window', 12, 3, 'black', 'true')</l>
<c>* We define the image pairs, i.e., which image should be mapped to which image.</c>
<l>* From := [1,2,3,4,5]</l>
<l>* To := [2,3,4,5,6]</l>
<l>Num := |From|</l>
<c>* We need a variable to accumulate the projective transformation matrices.</c>
<l>ProjMatrices := []</l>
<c>* Furthermore, since we want to create a rigid mosaic below we need to</c>
<c>* accumulate all the point correspondences and the number of matches per</c>
<c>* image pair.</c>
<l>Rows1 := []</l>
<l>Cols1 := []</l>
<l>Rows2 := []</l>
<l>Cols2 := []</l>
<l>NumMatches := []</l>
<c>* Now we can determine the transformations between the five image pairs.</c>
<l>for J := 0 to Num - 1 by 1</l>
<l>    F := From[J]</l>
<l>    T := To[J]</l>
<l>    select_obj (Images, ImageF, F)</l>
<l>    select_obj (Images, ImageT, T)</l>
<c>    * Extract the points in both images.</c>
<l>*     points_foerstner (ImageF, 1, 2, 3, 200, 0.3, 'gauss', 'false', RowJunctions, ColumnJunctions, CoRRJunctions, CoRCJunctions, CoCCJunctions, RowArea, ColumnArea, CoRRArea, CoRCArea, CoCCArea)</l>
<l>    points_foerstner (ImageF, 1, 2, 3, 200, 0.3, 'gauss', 'false', RowJunctionsF, ColJunctionsF, CoRRJunctionsF, CoRCJunctionsF, CoCCJunctionsF, RowAreaF, ColAreaF, CoRRAreaF, CoRCAreaF, CoCCAreaF)</l>
<l>    points_foerstner (ImageT, 1, 2, 3, 200, 0.3, 'gauss', 'false', RowJunctionsT, ColJunctionsT, CoRRJunctionsT, CoRCJunctionsT, CoCCJunctionsT, RowAreaT, ColAreaT, CoRRAreaT, CoRCAreaT, CoCCAreaT)</l>
<c>    * Determine the point matches and the transformation for the current</c>
<c>    * image pair.</c>
<l>    proj_match_points_ransac (ImageF, ImageT, RowJunctionsF, ColJunctionsF, RowJunctionsT, ColJunctionsT, 'ncc', 21, 0, 0, 480, 640, 0, 0.5, 'gold_standard', 1, 4364537, ProjMatrix, Points1, Points2)</l>
<c>    * Accumulate the transformation matrix.</c>
<l>    ProjMatrices := [ProjMatrices,ProjMatrix]</l>
<c>    * Accumulate the point matches and number of point matches.</c>
<l>    Rows1 := [Rows1,subset(RowJunctionsF,Points1)]</l>
<l>    Cols1 := [Cols1,subset(ColJunctionsF,Points1)]</l>
<l>    Rows2 := [Rows2,subset(RowJunctionsT,Points2)]</l>
<l>    Cols2 := [Cols2,subset(ColJunctionsT,Points2)]</l>
<l>    NumMatches := [NumMatches,|Points1|]</l>
<c>    * Generate crosses that represent the extracted points in the tiled image.</c>
<c>    * Note that we have to take the row offsets of the images in the tiled image</c>
<c>    * into account.</c>
<l>    gen_cross_contour_xld (PointsF, RowJunctionsF + (F - 1) * OffsetRow, ColJunctionsF, 6, rad(45))</l>
<l>    gen_cross_contour_xld (PointsT, RowJunctionsT + (T - 1) * OffsetRow, ColJunctionsT, 6, rad(45))</l>
<c>    * Generate a representation of the matched point pairs as lines.  We create</c>
<c>    * XLD contours from the lines so that we can zoom into the graphics window</c>
<c>    * to take a closer look at the matches.</c>
<l>    RowF := subset(RowJunctionsF,Points1) + (F - 1) * OffsetRow</l>
<l>    ColF := subset(ColJunctionsF,Points1)</l>
<l>    RowT := subset(RowJunctionsT,Points2) + (T - 1) * OffsetRow</l>
<l>    ColT := subset(ColJunctionsT,Points2)</l>
<l>    gen_empty_obj (Matches)</l>
<l>    for K := 0 to |RowF| - 1 by 1</l>
<l>        gen_contour_polygon_xld (Match, [RowF[K],RowT[K]], [ColF[K],ColT[K]])</l>
<l>        concat_obj (Matches, Match, Matches)</l>
<l>    endfor</l>
<c>    * Now display the extracted data.</c>
<l>    dev_set_color ('blue')</l>
<l>    dev_display (Matches)</l>
<l>    dev_set_color ('green')</l>
<l>    dev_display (PointsF)</l>
<l>    dev_display (PointsT)</l>
<l>endfor</l>
<l>disp_message (WindowHandle, 'Click \'Run\'\nto continue', 'window', 2980 / 4 - 50, 12, 'black', 'true')</l>
<l>stop ()</l>
<c>* Finally, we can generate the mosaic image from the projective transformations.</c>
<l>gen_projective_mosaic (Images, MosaicImage, 2, From, To, ProjMatrices, 'default', 'false', MosaicMatrices2D)</l>
<l>get_image_size (MosaicImage, Width, Height)</l>
<l>dev_set_window_extents (-1, -1, Width / 3, Height / 3)</l>
<l>dev_clear_window ()</l>
<l>dev_display (MosaicImage)</l>
<l>disp_message (WindowHandle, 'Projective mosaic', 'window', 12, 12, 'black', 'true')</l>
<l>disp_message (WindowHandle, 'Click \'Run\'\nto continue', 'window', Height / 3 - 50, 12, 'black', 'true')</l>
<l>stop ()</l>
<c>* To show more clearly that the folds visible in the image do not result from the</c>
<c>* mosaicking, we display the seams between the images in the mosaic image.</c>
<c>* This can be done most easily by creating an image that contains the border</c>
<c>* of the images, generating a mosaic from it, and segmenting the resulting</c>
<c>* mosaic image.</c>
<l>get_image_size (Image, Width, Height)</l>
<l>gen_image_const (ImageBlank, 'byte', Width, Height)</l>
<l>gen_rectangle1 (Rectangle, 0, 0, Height - 1, Width - 1)</l>
<l>paint_region (Rectangle, ImageBlank, ImageBorder, 255, 'margin')</l>
<l>gen_empty_obj (ImagesBorder)</l>
<l>for J := 1 to numdata by 1</l>
<l>    concat_obj (ImagesBorder, ImageBorder, ImagesBorder)</l>
<l>endfor</l>
<l>gen_projective_mosaic (ImagesBorder, MosaicImageBorder, 2, From, To, ProjMatrices, 'default', 'false', MosaicMatrices2D)</l>
<l>threshold (MosaicImageBorder, Seams, 128, 255)</l>
<l>dev_clear_window ()</l>
<l>dev_display (MosaicImage)</l>
<l>disp_message (WindowHandle, 'Seams between the\nimages', 'window', 12, 12, 'black', 'true')</l>
<l>dev_set_color ('yellow')</l>
<l>dev_display (Seams)</l>
<l>disp_message (WindowHandle, 'Click \'Run\'\nto continue', 'window', 550, 12, 'black', 'true')</l>
<l>stop ()</l>
<c>* If you look very closely at the projective mosaic above, you may note that</c>
<c>* there is a very slight projective distortion in the mosaic.  This happens</c>
<c>* because the transformations cannot be determined with perfect accuracy</c>
<c>* because of very small errors in the point coordinates due to noise.  Because</c>
<c>* of the strip configuration, essentially the overlapping area between the image</c>
<c>* pairs can act like a hinge around which the images may rotate out of the image</c>
<c>* plane.  In this example, we know that the mapping between the images must</c>
<c>* be a rigid transformation.  If we want to force the transformation to be rigid</c>
<c>* we can simply use bundle_adjust_mosaic.</c>
<l>bundle_adjust_mosaic (6, 1, From, To, ProjMatrices, Rows1, Cols1, Rows2, Cols2, NumMatches, 'rigid', MosaicMatrices2D, Rows, Cols, Error)</l>
<c>* Now, we can generate the mosaic image from the rigid transformations.</c>
<l>gen_bundle_adjusted_mosaic (Images, MosaicImageRigid, MosaicMatrices2D, 'default', 'false', TransMatrix2D)</l>
<l>get_image_size (MosaicImageRigid, Width, Height)</l>
<l>dev_set_window_extents (-1, -1, Width / 3, Height / 3)</l>
<l>dev_clear_window ()</l>
<l>dev_display (MosaicImageRigid)</l>
<l>disp_message (WindowHandle, 'Rigid mosaic', 'window', 12, 12, 'black', 'true')</l>
<l>close_framegrabber (AcqHandle)</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
